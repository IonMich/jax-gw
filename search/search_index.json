{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation of JAX GW","text":"<p>This is the documentation of the JAX GW project, which is a collection of scripts and tools to perform GW analysis in JAX. The initial emphasis is in the characterization of astrophysical gravitational-wave backgrounds.</p> <p>Note</p> <p>The package is still in early development. See below.</p>"},{"location":"#tasks-before-initial-release","title":"Tasks before initial release","text":"<ul> <li> Orbits for ground and space interferometers<ul> <li> Approximate orbit evolution for ground-based interferometer</li> <li> Approximate orbit evolution for space-borne GW constellations</li> <li> Specific configuration of currently operational observatories</li> <li> Initial set of automated tests</li> </ul> </li> <li> Response function<ul> <li> Timing response of a one-way photon arm (in the flexible adiabatic approximation of Cornish 2004)</li> <li> Response of a round-trip arm</li> <li> Response of an arbitrary photon path</li> <li> Response of an arbitrary combination of paths</li> <li> Option to restrict the collection of available pairwise paths</li> <li> Michelson response</li> <li> TDI responses up to TDI-2.0 for N=3</li> <li> TDI responses up to TDI-2.0 for arbitrary N</li> <li> Circularly-permuted path definitions</li> <li> Initial set of automated tests</li> </ul> </li> <li> Overlap Reduction Function (ORF)<ul> <li> Calculate the anisotropic ORF between two channels.</li> <li> Caclulate the isotropic ORF from its anisotropic counterpart.</li> <li> Initial set of automated tests</li> </ul> </li> <li> Signal Processing<ul> <li> Project continuous signal to observatory</li> <li> Estimate required frequency and temporal resolution (and range) for the pipelines of interest.</li> <li> Implement noise power spectral densities (PSDs) of current and future observatories.</li> <li> Generate Point Spread Functions (i.e. Beam Patterns)</li> <li> Calculate Angular Power Spectra <code>N_l</code></li> <li> Use PSDs to synthesize noise for arbitrary channels.</li> <li> Project a Gaussian stochastic signal realization to a channel</li> <li> Project a Gaussian stochastic signal realization to overlap of channels</li> <li> Initial set of automated tests</li> </ul> </li> <li> Stochastic Gravitational Wave Background (SGWB) Modeling<ul> <li> Store anisotropic SGWB astrophysical kernels in 1st order perturbation theory</li> <li> Calculate signal <code>C_ells</code> from astrophysical kernels and matter power spectra</li> <li> Calculate shot-noise contributions to the astrophysical signal</li> <li> Add SGWB isotropic PSDs for sources of interest</li> <li> Add SGWB anisotropic PSDs for sources of interest</li> <li> Generate realizations of the SGWB PSDs.</li> <li> Initial set of automated tests</li> </ul> </li> <li> Sky Basis<ul> <li> Generate sky basis in a <code>(theta, phi)</code> grid.</li> <li> Generate sky basis in <code>(ell, m)</code> space.</li> <li> Convert between <code>(ell, m)</code> and pixel-based grids.</li> <li> (Maybe) Implement a HEALPix pixelization scheme.</li> <li> Initial set of automated tests</li> </ul> </li> <li> Parameter Estimation<ul> <li> Add Numpyro support</li> <li> Add isotropic PE pipeline</li> <li> Add anisotropic PE pipeline in <code>ell</code> space.</li> <li> Initial set of automated tests</li> </ul> </li> <li> Waveforms<ul> <li> Add Ripple support</li> <li> Initial set of automated tests</li> </ul> </li> </ul>"},{"location":"orbits/","title":"Documentation for <code>detector.orbits</code>","text":""},{"location":"orbits/#src.jax_gw.detector.orbits.axial_tilt","title":"<code>axial_tilt(equatorial_coords, earth_tilt)</code>","text":"<p>Rotate a vector by an angle <code>tilt</code> around the x-axis. Convert from equatorial to ecliptic coordinates when <code>earth_tilt</code> is the positive Earth's tilt.</p> <p>Parameters:</p> Name Type Description Default <code>equatorial_coords</code> <code>ArrayLike</code> <p>Vector in equatorial coordinates.</p> required <code>earth_tilt</code> <code>float</code> <p>Angle to rotate around the x-axis.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Vector in ecliptic coordinates.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def axial_tilt(equatorial_coords: ArrayLike, earth_tilt: float) -&gt; Array:\n    \"\"\"Rotate a vector by an angle `tilt` around the x-axis.\n    Convert from equatorial to ecliptic coordinates when `earth_tilt` is the positive Earth's tilt.\n\n    Parameters\n    ----------\n    equatorial_coords : ArrayLike\n        Vector in equatorial coordinates.\n    earth_tilt : float\n        Angle to rotate around the x-axis.\n\n    Returns\n    -------\n    Array\n        Vector in ecliptic coordinates.\n    \"\"\"\n    rot_matrix = jnp.array(\n        [\n            [1.0, 0.0, 0.0],\n            [0.0, jnp.cos(earth_tilt), jnp.sin(earth_tilt)],\n            [0.0, -jnp.sin(earth_tilt), jnp.cos(earth_tilt)],\n        ]\n    )\n    return jnp.dot(rot_matrix, equatorial_coords)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.create_cartwheel_arm_lengths","title":"<code>create_cartwheel_arm_lengths(ecc, r, N, times, freq=1.0)</code>","text":"<p>Create the scalar separations for a cartwheel orbit.</p> <p>Parameters:</p> Name Type Description Default <code>ecc</code> <code>float</code> <p>Eccentricity of the orbit.</p> required <code>r</code> <code>float</code> <p>Radius of the orbit of the guiding center.</p> required <code>N</code> <code>int</code> <p>Number of spacecraft.</p> required <code>times</code> <code>array</code> <p>Times at which to evaluate the orbit.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Separations. Dimensions: (len(times), N, N).</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def create_cartwheel_arm_lengths(\n    ecc: float,\n    r: float,\n    N: int,\n    times: ArrayLike,\n    freq: float = 1.0,\n) -&gt; Array:\n    \"\"\"Create the scalar separations for a cartwheel orbit.\n\n    Parameters\n    ----------\n    ecc : float\n        Eccentricity of the orbit.\n    r : float\n        Radius of the orbit of the guiding center.\n    N : int\n        Number of spacecraft.\n    times : jnp.array\n        Times at which to evaluate the orbit.\n\n    Returns\n    -------\n    jnp.array\n        Separations. Dimensions: (len(times), N, N).\n    \"\"\"\n    assert N == 3\n    L = 2.0 * jnp.sqrt(3) * ecc * r\n\n    lambda_cart = 0.0\n    kappa_orbit = -20.0 / 360.0 * 2 * jnp.pi\n    alpha = 2.0 * jnp.pi * freq * times + kappa_orbit\n\n    exp_1_n1 = jnp.exp(1j * (alpha - lambda_cart))\n    cos_1_n1 = jnp.real(exp_1_n1)\n    cos_3_n3 = jnp.real(exp_1_n1**3)\n    sin_1_n1_pi6 = jnp.imag(exp_1_n1 * jnp.exp(1j * jnp.pi / 6.0))\n    sin_1_n1_npi6 = jnp.imag(exp_1_n1 * jnp.exp(-1j * jnp.pi / 6.0))\n\n    arm_12 = L * (1 + ecc / 32.0 * (15.0 * sin_1_n1_pi6 - cos_3_n3))\n    arm_13 = L * (1 - ecc / 32.0 * (15.0 * sin_1_n1_npi6 + cos_3_n3))\n    arm_23 = L * (1 - ecc / 32.0 * (15.0 * cos_1_n1 + cos_3_n3))\n\n    separations_flat = jnp.stack([arm_12, arm_13, arm_23], axis=0)\n\n    d = jnp.zeros((N, N, len(times)))\n    d = d.at[0, 1, :].set(separations_flat[0, :])\n    d = d.at[1, 0, :].set(separations_flat[0, :])\n    d = d.at[0, 2, :].set(separations_flat[1, :])\n    d = d.at[2, 0, :].set(separations_flat[1, :])\n    d = d.at[1, 2, :].set(separations_flat[2, :])\n    d = d.at[2, 1, :].set(separations_flat[2, :])\n\n    # move the time axis to the front\n    d = jnp.moveaxis(d, -1, 0)\n\n    return d\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.create_cartwheel_orbit","title":"<code>create_cartwheel_orbit(ecc, r, N, times, timeshift=0, freq=1.0)</code>","text":"<p>Create a cartwheel orbit.</p> <p>Parameters:</p> Name Type Description Default <code>ecc</code> <code>float</code> <p>Eccentricity of the orbits.</p> required <code>r</code> <code>float</code> <p>Radius of the orbit of the guiding center. Units: AU.</p> required <code>N</code> <code>int</code> <p>Number of spacecraft.</p> required <code>times</code> <code>ArrayLike</code> <p>Times at which to evaluate the orbit. Units: years.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Orbit. Dimensions: (N, 3, len(times)). Units: AU.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def create_cartwheel_orbit(\n    ecc: float,\n    r: float,\n    N: int,\n    times: ArrayLike,\n    timeshift: float = 0,\n    freq: float = 1.0,\n) -&gt; Array:\n    \"\"\"Create a cartwheel orbit.\n\n    Parameters\n    ----------\n    ecc : float\n        Eccentricity of the orbits.\n    r : float\n        Radius of the orbit of the guiding center. Units: AU.\n    N : int\n        Number of spacecraft.\n    times : ArrayLike\n        Times at which to evaluate the orbit. Units: years.\n\n    Returns\n    -------\n    Array\n        Orbit. Dimensions: (N, 3, len(times)). Units: AU.\n    \"\"\"\n    # kappa is 20 degrees behind Earth\n    kappa_orbit = -20.0 / 360.0 * 2 * jnp.pi\n    lambda_cart = timeshift\n    alpha = 2.0 * jnp.pi * freq * times + kappa_orbit\n    beta_n = jnp.arange(N)[:, jnp.newaxis] * 2.0 * jnp.pi / N + lambda_cart\n\n    exp_1_0 = jnp.exp(1j * (alpha))\n    exp_2_n1 = jnp.exp(1j * (2 * alpha - beta_n))\n    exp_0_1 = jnp.exp(1j * (beta_n))\n    exp_3_n2 = jnp.exp(1j * (3 * alpha - 2 * beta_n))\n    exp_1_n2 = jnp.exp(1j * (alpha - 2 * beta_n))\n\n    term_1 = r * exp_1_0\n    term_2 = 0.5 * r * ecc * (exp_2_n1 - 3.0 * exp_0_1)\n    term_3 = 0.125 * r * ecc**2 * (3.0 * exp_3_n2 - 10.0 * exp_1_0)\n    term_4 = 0.125 * r * ecc**2 * 5.0 * exp_1_n2\n\n    L = jnp.sqrt(3) * ecc * r\n    exp_1_n1 = jnp.exp(1j * (alpha - beta_n))\n    cos_1_n1, sin_1_n1 = jnp.real(exp_1_n1), jnp.imag(exp_1_n1)\n\n    common_x_y = term_1 + term_2 + term_3\n\n    x = jnp.real(common_x_y - term_4)\n    y = jnp.imag(common_x_y + term_4)\n    z = -L * cos_1_n1 + L * ecc * (1 + sin_1_n1**2)\n\n    return jnp.stack([x, y, z], axis=1)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.create_circular_orbit_xy","title":"<code>create_circular_orbit_xy(r, f_orb, times)</code>","text":"<p>Create an orbit around the Sun with x and y Arms.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Radius of the orbit.</p> required <code>times</code> <code>array</code> <p>Times at which to evaluate the orbit.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Orbit. Dimensions: (1, 3, len(times)).</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def create_circular_orbit_xy(r: float, f_orb: float, times: ArrayLike) -&gt; Array:\n    \"\"\"Create an orbit around the Sun with x and y Arms.\n\n    Parameters\n    ----------\n    r : float\n        Radius of the orbit.\n    times : jnp.array\n        Times at which to evaluate the orbit.\n\n    Returns\n    -------\n    jnp.array\n        Orbit. Dimensions: (1, 3, len(times)).\n    \"\"\"\n    # for now let's assume a circular orbit on the ecliptic plane\n    x = r * jnp.cos(2.0 * jnp.pi * f_orb * times)\n    y = r * jnp.sin(2.0 * jnp.pi * f_orb * times)\n    z = jnp.zeros_like(x)\n\n    return jnp.stack([x, y, z], axis=0)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.earthbound_ifo_pipeline","title":"<code>earthbound_ifo_pipeline(lat, lon, times, r, L_arm, psi=0, beta_arm=jnp.pi / 2)</code>","text":"<p>Create the orbits of the spacecraft for an Earthbound interferometer. Currently only works for perpendicular arms and assumes a circular orbit with the Earth modeled as a sphere.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Earth latitude in radians. Zero is the equator, +pi/2 is the North pole.</p> required <code>lon</code> <code>float</code> <p>Earth longitude in radians. Zero is the Greenwich meridian, positive is East.</p> required <code>times</code> <code>array</code> <p>Times at which to evaluate the orbit in years.</p> required <code>r</code> <code>float</code> <p>Radius of the orbit in AU.</p> required <code>L_arm</code> <code>float</code> <p>Length of the arms in km.</p> required <code>psi</code> <code>float</code> <p>Angle between the X arm and local East in radians. Positive North of East. The Y arm is rotated by an additional pi/2.</p> <code>0</code> <code>beta_arm</code> <code>float</code> <p>Angle between the X and Y arms in radians.</p> <code>pi / 2</code> <p>Returns:</p> Type Description <code>array</code> <p>Orbits of the N=3 points defining the interferometer. Dimensions: (N, 3, len(times)).</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def earthbound_ifo_pipeline(\n    lat: float,\n    lon: float,\n    times: ArrayLike,\n    r: float,\n    L_arm: float,\n    psi: float = 0,\n    beta_arm: float = jnp.pi / 2,\n) -&gt; Array:\n    \"\"\"Create the orbits of the spacecraft for an Earthbound interferometer.\n    Currently only works for perpendicular arms and assumes a circular orbit\n    with the Earth modeled as a sphere.\n\n    Parameters\n    ----------\n    lat : float\n        Earth latitude in radians. Zero is the equator, +pi/2 is the North pole.\n    lon : float\n        Earth longitude in radians. Zero is the Greenwich meridian, positive is East.\n    times : jnp.array\n        Times at which to evaluate the orbit in years.\n    r : float\n        Radius of the orbit in AU.\n    L_arm : float\n        Length of the arms in km.\n    psi : float\n        Angle between the X arm and local East in radians. Positive North of East. The Y arm is rotated by an additional pi/2.\n    beta_arm : float\n        Angle between the X and Y arms in radians.\n\n    Returns\n    -------\n    jnp.array\n        Orbits of the N=3 points defining the interferometer. Dimensions: (N, 3, len(times)).\n    \"\"\"\n    FREQ_CENTER_ORBIT = 1  # in 1/year\n    FREQ_ROTATION = 365.25  # in 1/year\n    r_orbital = create_circular_orbit_xy(r, FREQ_CENTER_ORBIT, times)\n\n    # calculate x, y, z coordinates of detector with respect to the guiding center\n    # at time t=0\n    r_detector_initial_equatorial = lat_lon_to_cartesian(lat, lon)\n\n    hour_angle = 2.0 * jnp.pi * FREQ_ROTATION * times\n    r_detector = equatorial_timeshift(r_detector_initial_equatorial, hour_angle)\n\n    r_detector = axial_tilt(r_detector, EARTH_TILT)\n\n    r_earth_in_km = 6371.0\n    # local East unit direction at the detector\n    north_pole_equatorial = jnp.array([0.0, 0.0, 1.0])\n    local_east = jnp.cross(north_pole_equatorial, r_detector_initial_equatorial)\n    local_east = local_east / jnp.linalg.norm(local_east)\n    # rotate the arms by psi with respect to r_detector_initial_equatorial\n    # by applying the matrix form of Rodrigues' rotation formula\n    K_matrix = jnp.array(\n        [\n            [0.0, -r_detector_initial_equatorial[2], r_detector_initial_equatorial[1]],\n            [r_detector_initial_equatorial[2], 0.0, -r_detector_initial_equatorial[0]],\n            [-r_detector_initial_equatorial[1], r_detector_initial_equatorial[0], 0.0],\n        ]\n    )\n    rotation_matrix_psi = (\n        jnp.eye(3) + jnp.sin(psi) * K_matrix + (1 - jnp.cos(psi)) * K_matrix @ K_matrix\n    )\n    rotation_matrix_beta = (\n        jnp.eye(3)\n        + jnp.sin(beta_arm) * K_matrix\n        + (1 - jnp.cos(beta_arm)) * K_matrix @ K_matrix\n    )\n    x_arm_direction = rotation_matrix_psi @ local_east\n    y_arm_direction = rotation_matrix_beta @ x_arm_direction\n    print(x_arm_direction)\n    print(y_arm_direction)\n    arm_length = L_arm / r_earth_in_km\n    x_arm_local_equatorial_initial = arm_length * x_arm_direction\n    y_arm_local_equatorial_initial = arm_length * y_arm_direction\n    # convert from equatorial to ecliptic coordinates\n    x_arm_ecliptic_initial = axial_tilt(x_arm_local_equatorial_initial, +EARTH_TILT)\n    print(x_arm_ecliptic_initial)\n    y_arm_ecliptic_initial = axial_tilt(y_arm_local_equatorial_initial, +EARTH_TILT)\n    print(y_arm_ecliptic_initial)\n\n    # x_arm_ecliptic_initial = jnp.array([L_arm / r_earth_in_km, 0.0, 0.0])\n    # y_arm_ecliptic_initial = jnp.array([0.0, L_arm / r_earth_in_km, 0.0])\n    x_arm = ecliptic_timeshift(x_arm_ecliptic_initial, hour_angle, EARTH_TILT)\n    y_arm = ecliptic_timeshift(y_arm_ecliptic_initial, hour_angle, EARTH_TILT)\n\n    # add a rotation around this guiding center, assuming a solid body like the Earth\n    AU_per_billion_meters = 149.597871\n    AU_per_earth_radius = (AU_per_billion_meters * 1e9) / (r_earth_in_km * 1e3)\n    print(AU_per_earth_radius)\n\n    r_detector = jnp.array(r_detector, dtype=jnp.float64)\n    r_beam_splitter = r_orbital + r_detector / AU_per_earth_radius\n\n    x_arm = jnp.array(x_arm, dtype=jnp.float64) / AU_per_earth_radius\n    y_arm = jnp.array(y_arm, dtype=jnp.float64) / AU_per_earth_radius\n    x_arm = r_beam_splitter + x_arm\n    y_arm = r_beam_splitter + y_arm\n\n    orbits = jnp.stack([r_beam_splitter, x_arm, y_arm], axis=0)\n\n    return orbits\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.ecliptic_timeshift","title":"<code>ecliptic_timeshift(ecliptic_coords, angle, tilt)</code>","text":"<p>Rotate a vector in ecliptic coordinates by an angle <code>angle</code> around the z-axis of equatorial coordinates. Shift ecliptic coordinates to a hour <code>angle</code> later.</p> <p>Parameters:</p> Name Type Description Default <code>ecliptic_coords</code> <code>ArrayLike</code> <p>Vector in ecliptic  coordinates.</p> required <code>angle</code> <code>ArrayLike</code> <p>Angle to rotate around the z-axis of equatorial coordinates.</p> required <code>tilt</code> <code>float</code> <p>Angle to rotate around the x-axis.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Vector in equatorial coordinates at time shifted by <code>angle</code>.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def ecliptic_timeshift(\n    ecliptic_coords: ArrayLike, angle: ArrayLike, tilt: float\n) -&gt; Array:\n    \"\"\"Rotate a vector in ecliptic coordinates by an angle `angle` around the z-axis of equatorial coordinates.\n    Shift ecliptic coordinates to a hour `angle` later.\n\n    Parameters\n    ----------\n    ecliptic_coords : ArrayLike\n        Vector in ecliptic  coordinates.\n    angle : ArrayLike\n        Angle to rotate around the z-axis of equatorial coordinates.\n    tilt : float\n        Angle to rotate around the x-axis.\n\n    Returns\n    -------\n    Array\n        Vector in equatorial coordinates at time shifted by `angle`.\n    \"\"\"\n    equatorial_initial = axial_tilt(ecliptic_coords, -tilt)\n\n    equatorial_coords = equatorial_timeshift(equatorial_initial, angle)\n    ecliptic_coords = axial_tilt(equatorial_coords, tilt)\n\n    return ecliptic_coords\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.equatorial_timeshift","title":"<code>equatorial_timeshift(equatorial_coords, angle)</code>","text":"<p>Rotate a vector by an angle <code>angle</code> around the z-axis of equatorial coordinates. Shift equatorial coordinates to a hour <code>angle</code> later.</p> <p>Parameters:</p> Name Type Description Default <code>equatorial_coords</code> <code>ArrayLike</code> <p>Vector in equatorial coordinates.</p> required <code>angle</code> <code>ArrayLike</code> <p>Angle to rotate around the z-axis.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Vector in equatorial coordinates at time shifted by <code>angle</code>.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def equatorial_timeshift(equatorial_coords: ArrayLike, angle: ArrayLike) -&gt; Array:\n    \"\"\"Rotate a vector by an angle `angle` around the z-axis of equatorial coordinates.\n    Shift equatorial coordinates to a hour `angle` later.\n\n    Parameters\n    ----------\n    equatorial_coords : ArrayLike\n        Vector in equatorial coordinates.\n    angle : ArrayLike\n        Angle to rotate around the z-axis.\n\n    Returns\n    -------\n    Array\n        Vector in equatorial coordinates at time shifted by `angle`.\n    \"\"\"\n    x, y, z = equatorial_coords\n    cos_angle = jnp.cos(angle)\n    sin_angle = jnp.sin(angle)\n\n    x_return = cos_angle * x + sin_angle * y\n    y_return = -sin_angle * x + cos_angle * y\n    z_return = z * jnp.ones_like(x_return)\n    return jnp.stack([x_return, y_return, z_return], axis=0)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.flat_index","title":"<code>flat_index(i, j, N)</code>","text":"<p>Calculate the flat index for a pair of indices i, j.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int32</code> <p>First index.</p> required <code>j</code> <code>int32</code> <p>Second index.</p> required <code>N</code> <code>int</code> <p>Possible values for i (or j).</p> required <p>Returns:</p> Type Description <code>int32</code> <p>Flat index for the pair of indices corresponding to the pair of spacecraft.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def flat_index(i: jnp.int32, j: jnp.int32, N: int) -&gt; jnp.int32:\n    \"\"\"Calculate the flat index for a pair of indices i, j.\n\n    Parameters\n    ----------\n    i : jnp.int32\n        First index.\n    j : jnp.int32\n        Second index.\n    N : int\n        Possible values for i (or j).\n\n    Returns\n    -------\n    jnp.int32\n        Flat index for the pair of indices corresponding to the pair of\n        spacecraft.\n    \"\"\"\n    min_ij = jnp.minimum(i, j)\n    max_ij = jnp.maximum(i, j)\n    # returns 0 if i &lt; j and 1 if i &gt; j\n    really_fast_index = jnp.greater(i, j)\n    fast_index = 2 * (max_ij - min_ij - 1)\n    slow_index = min_ij * (2 * N - min_ij - 1)\n\n    return really_fast_index + fast_index + slow_index\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.flat_to_matrix_indices","title":"<code>flat_to_matrix_indices(N)</code>","text":"<p>Calculate the (N*(N-1), 2) matrix of flat indices for a given number of spacecraft.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of spacecraft.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Matrix of flat indices.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def flat_to_matrix_indices(\n    N: int,\n) -&gt; Array:\n    \"\"\"Calculate the (N*(N-1), 2) matrix of flat indices for a given number of\n    spacecraft.\n\n    Parameters\n    ----------\n    N : int\n        Number of spacecraft.\n\n    Returns\n    -------\n    jnp.array\n        Matrix of flat indices.\n    \"\"\"\n    # create the matrix of flat indices\n    flat_indices = jnp.zeros((N * (N - 1), 2), dtype=jnp.int32)\n\n    index_func = jax.jit(flat_index)\n    for i, j in zip(*jnp.triu_indices(N, k=1)):\n        k = index_func(i, j, N)\n        flat_indices = flat_indices.at[k, :].set(jnp.stack([i, j], axis=0))\n        k = index_func(j, i, N)\n        flat_indices = flat_indices.at[k, :].set(jnp.stack([j, i], axis=0))\n\n    return flat_indices\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.flatten_pairs","title":"<code>flatten_pairs(matrix_form)</code>","text":"<p>Flatten the separations or receiver positions from a pair of indices to a single dimension of length N * (N - 1).</p> <p>Parameters:</p> Name Type Description Default <code>matrix_form</code> <code>array</code> <p>Separations or receiver positions in matrix form.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Flattened separations and receiver positions with shape (N_steps, N * (N - 1), 3).</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>@jax.jit\ndef flatten_pairs(\n    matrix_form: ArrayLike,\n) -&gt; Array:\n    \"\"\"Flatten the separations or receiver positions from a pair of indices\n    to a single dimension of length N * (N - 1).\n\n    Parameters\n    ----------\n    matrix_form : jnp.array\n        Separations or receiver positions in matrix form.\n\n    Returns\n    -------\n    jnp.array\n        Flattened separations and receiver positions with shape (N_steps, N * (N - 1), 3).\n    \"\"\"\n    N1, N2 = matrix_form.shape[1], matrix_form.shape[2]\n    N = max(N1, N2)\n    # use of minimum is to avoid out of bounds error when N1 or N2 has length 1\n    vmapped_flat_index = jax.vmap(\n        lambda i, j: matrix_form[:, jnp.minimum(i, N1), jnp.minimum(j, N2), ...],\n        in_axes=(0, 0),\n        out_axes=0,\n    )\n    indices = flat_to_matrix_indices(N)\n    receivers, emitters = indices[:, 0], indices[:, 1]\n    return vmapped_flat_index(receivers, emitters)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.get_arm_lengths","title":"<code>get_arm_lengths(separations)</code>","text":"<p>Calculate the arm lengths from the vector separations.</p> <p>Parameters:</p> Name Type Description Default <code>separations</code> <code>ndarray</code> <p>Vector separations. Last dimension must be of length 3.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Arm lengths in shape <code>(N_steps, N, N)</code>.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def get_arm_lengths(separations: ArrayLike) -&gt; Array:\n    \"\"\"Calculate the arm lengths from the vector separations.\n\n    Parameters\n    ----------\n    separations : jnp.ndarray\n        Vector separations. Last dimension must be of length 3.\n\n    Returns\n    -------\n    jnp.ndarray\n        Arm lengths in shape `(N_steps, N, N)`.\n    \"\"\"\n    d = jnp.linalg.norm(separations, axis=-1)\n\n    return d\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.get_emitter_positions","title":"<code>get_emitter_positions(position)</code>","text":"<p>Calculate the emitter positions of the spacecraft for a given arm. Since the separation matrix is defined as r[i, j] = r[i] - r[j], the emitter positions must be calculated as e_pos[i, j, 3, N...] = pos[j, 3, N...].</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>array</code> <p>Position of the spacecraft. Shape (N, 3, ...).</p> required <p>Returns:</p> Type Description <code>array</code> <p>Emitter spacecraft positions for the arm. Same shape as separations.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def get_emitter_positions(\n    position: ArrayLike,\n) -&gt; Array:\n    \"\"\"Calculate the emitter positions of the spacecraft for a given arm.\n    Since the separation matrix is defined as r[i, j] = r[i] - r[j], the\n    emitter positions must be calculated as e_pos[i, j, 3, N...] = pos[j, 3, N...].\n    Parameters\n    ----------\n    position : jnp.array\n        Position of the spacecraft. Shape (N, 3, ...).\n\n    Returns\n    -------\n    jnp.array\n        Emitter spacecraft positions for the arm. Same shape as separations.\n    \"\"\"\n    # first create a newaxis for the i index\n    pos = position[jnp.newaxis, :, :, ...]\n    # then move the time axis to the front, if it exists\n    from_idx = [0, 1, 2]\n    to_idx = [-3, -2, -1]\n    pos = jnp.moveaxis(pos, from_idx, to_idx)\n\n    return pos\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.get_receiver_positions","title":"<code>get_receiver_positions(position)</code>","text":"<p>Calculate the receiver positions of the spacecraft for a collection of arms. Since the separation matrix is defined as <code>r[i, j] = r[i] - r[j]</code>, the receiver positions must be defined via <code>r_pos[i, j, 3, N...] = pos[i, 3, N...]</code>. Positions has shape <code>(N, 3, N_steps)</code> while separations has shape <code>(N_steps, N, N, 3)</code>. Therefore, we need to create a newaxis for the <code>j</code> index, and finally move the time axis to the front.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ArrayLike</code> <p>Position of the spacecraft. Shape (N, 3, ...).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Receiver spacecraft positions for the arm. Shape broadcastable to the shape of separations.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def get_receiver_positions(\n    position: ArrayLike,\n) -&gt; Array:\n    \"\"\"Calculate the receiver positions of the spacecraft for a collection of arms.\n    Since the separation matrix is defined as `r[i, j] = r[i] - r[j]`, the\n    receiver positions must be defined via `r_pos[i, j, 3, N...] = pos[i, 3, N...]`.\n    Positions has shape `(N, 3, N_steps)` while separations has shape\n    `(N_steps, N, N, 3)`. Therefore, we need to create a newaxis for the `j` index,\n    and finally move the time axis to the front.\n\n    Parameters\n    ----------\n    position : ArrayLike\n        Position of the spacecraft. Shape (N, 3, ...).\n\n    Returns\n    -------\n    Array\n        Receiver spacecraft positions for the arm. Shape broadcastable to\n        the shape of separations.\n    \"\"\"\n\n    # first create a newaxis for the j index\n    pos = position[:, jnp.newaxis, :, ...]\n    # then move the time axis to the front, if it exists\n    from_idx = [0, 1, 2]\n    to_idx = [-3, -2, -1]\n    pos = jnp.moveaxis(pos, from_idx, to_idx)\n\n    return pos\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.get_separations","title":"<code>get_separations(orbits)</code>","text":"<p>Calculate the vector separations between the spacecraft.</p> <p><code>r_{ij} = r_i - r_j</code></p> <p>Parameters:</p> Name Type Description Default <code>orbits</code> <code>ArrayLike</code> <p>Array of shape <code>(N, 3, N_steps)</code> containing the orbits of the N spacecraft.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Vector separations. Dimensions: <code>(N_steps, N, N, 3)</code>.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def get_separations(orbits: ArrayLike) -&gt; Array:\n    \"\"\"Calculate the vector separations between the spacecraft.\n\n    `r_{ij} = r_i - r_j`\n\n    Parameters\n    ----------\n    orbits : ArrayLike\n        Array of shape `(N, 3, N_steps)` containing the orbits of the N\n        spacecraft.\n\n    Returns\n    -------\n    Array\n        Vector separations. Dimensions: `(N_steps, N, N, 3)`.\n    \"\"\"\n    # calculate the vector separations\n    N_steps, N = orbits.shape[2], orbits.shape[0]\n    r = jnp.zeros((N_steps, N, N, 3))\n    for i in range(N):\n        for j in range(N):\n            r = r.at[:, i, j, :].set(jnp.transpose(orbits[i, :, :] - orbits[j, :, :]))\n\n    return r\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.get_vertex_angle","title":"<code>get_vertex_angle(orbits)</code>","text":"<p>get the angle between the two arms of the interferometer using the initial positions of the two arms</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def get_vertex_angle(orbits):\n    \"\"\"\n    get the angle between the two arms of the interferometer\n    using the initial positions of the two arms\n    \"\"\"\n    x_arm = (orbits[1] - orbits[0])[:, 0]\n    y_arm = (orbits[2] - orbits[0])[:, 0]\n    # get the angle between the two arms of the interferometer\n    vertex_angle = jnp.arccos(\n        jnp.dot(x_arm, y_arm) / (jnp.linalg.norm(x_arm) * jnp.linalg.norm(y_arm))\n    )\n    return vertex_angle.item()\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.lat_lon_to_cartesian","title":"<code>lat_lon_to_cartesian(lat, lon, r=1)</code>","text":"<p>Convert latitude and longitude to equatorial cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude in radians.</p> required <code>lon</code> <code>float</code> <p>Longitude in radians.</p> required <code>r</code> <code>float</code> <p>Radius.</p> <code>1</code> <p>Returns:</p> Type Description <code>array</code> <p>Equatorial cartesian coordinates.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def lat_lon_to_cartesian(lat: float, lon: float, r: float = 1) -&gt; Array:\n    \"\"\"Convert latitude and longitude to equatorial cartesian coordinates.\n\n    Parameters\n    ----------\n    lat : float\n        Latitude in radians.\n    lon : float\n        Longitude in radians.\n    r : float\n        Radius.\n\n    Returns\n    -------\n    jnp.array\n        Equatorial cartesian coordinates.\n    \"\"\"\n    x = r * jnp.cos(lat) * jnp.cos(lon)\n    y = r * jnp.cos(lat) * jnp.sin(lon)\n    z = r * jnp.sin(lat)\n\n    return jnp.stack([x, y, z], axis=0)\n</code></pre>"},{"location":"orbits/#src.jax_gw.detector.orbits.path_from_indices","title":"<code>path_from_indices(indices)</code>","text":"<p>Convert an array of indices of spacecraft and length N_depth+1 to a path that is a 1D array of length N_depth and contains the arm index for each part of the path.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>array</code> <p>Array of indices of spacecraft and length N_depth+1.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Path that is a 1D array of length N_depth and contains the arm index for each part of the path.</p> Source code in <code>src/jax_gw/detector/orbits.py</code> <pre><code>def path_from_indices(indices: ArrayLike) -&gt; Array:\n    \"\"\"Convert an array of indices of spacecraft and length N_depth+1 to a path\n    that is a 1D array of length N_depth and contains the arm index for each part of the path.\n\n    Parameters\n    ----------\n    indices : jnp.array\n        Array of indices of spacecraft and length N_depth+1.\n\n    Returns\n    -------\n    jnp.array\n        Path that is a 1D array of length N_depth and contains the arm index for each part of the path.\n    \"\"\"\n    # first from (N_paths, N_depth+1,) to (N_paths, N_depth+1, 2), where the last axis contains the indices\n    # shifted by one, so that (..., i, 0) is the start and (..., i, 1) is the end of the segment i of the path\n    indices = jnp.stack([indices, jnp.roll(indices, -1, axis=-1)], axis=-1)\n    # remove the last row\n    indices = indices[..., :-1, :]\n\n    return indices\n</code></pre>"},{"location":"response/","title":"Documentation for <code>detector.response</code>","text":""},{"location":"response/#src.jax_gw.detector.response.antenna_pattern","title":"<code>antenna_pattern(u_hat, v_hat, arm_direction)</code>","text":"<p>Calculate the antenna pattern for a given source direction.</p> <p>Parameters:</p> Name Type Description Default <code>u_hat</code> <code>ArrayLike</code> <p>First unit vector in the transverse plane of the incoming signal.</p> required <code>v_hat</code> <code>ArrayLike</code> <p>Second unit vector in the transverse plane of the incoming signal.</p> required <code>arm_direction</code> <code>ArrayLike</code> <p>Unit vector pointing along the arm from the emitter to the receiver.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Plus and cross antenna pattern functions.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def antenna_pattern(\n    u_hat: ArrayLike,\n    v_hat: ArrayLike,\n    arm_direction: ArrayLike,\n) -&gt; Array:\n    \"\"\"Calculate the antenna pattern for a given source direction.\n\n    Parameters\n    -------\n    u_hat : ArrayLike\n        First unit vector in the transverse plane of the incoming signal.\n    v_hat : ArrayLike\n        Second unit vector in the transverse plane of the incoming signal.\n    arm_direction : ArrayLike\n        Unit vector pointing along the arm from the emitter to the receiver.\n\n    Returns\n    -------\n    jnp.array\n        Plus and cross antenna pattern functions.\n    \"\"\"\n    ksi_plus = jnp.dot(arm_direction, u_hat) ** 2 - jnp.dot(arm_direction, v_hat) ** 2\n    ksi_cross = 2 * jnp.dot(arm_direction, u_hat) * jnp.dot(arm_direction, v_hat)\n\n    return jnp.stack([ksi_plus, ksi_cross], axis=-1)\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.get_differential_strain_response","title":"<code>get_differential_strain_response(path_response, path_idx_1, path_idx_2, cumul_path_separations)</code>","text":"<p>Calculate the strain response from the difference in the responses of two photon paths, of equal cumulative length, i.e.</p> <p><code>R_{diff} = (R[path_idx_1] - R[path_idx_2]) / ( L_tot / c)</code></p> <p>Parameters:</p> Name Type Description Default <code>path_response</code> <code>ArrayLike</code> <p>Timing response function for a collection of photon paths.</p> required <code>path_idx_1</code> <code>int</code> <p>Index of the first photon path.</p> required <code>path_idx_2</code> <code>int</code> <p>Index of the second photon path.</p> required <code>cumul_path_separations</code> <code>ArrayLike</code> <p>Cumulative path lengths for the photon paths.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Michelson strain response for the two chosen photon paths.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def get_differential_strain_response(\n    path_response: ArrayLike,\n    path_idx_1: int,\n    path_idx_2: int,\n    cumul_path_separations: ArrayLike,\n):\n    \"\"\"Calculate the strain response from the difference in the responses of two photon paths,\n    of equal cumulative length, i.e.\n\n    `R_{diff} = (R[path_idx_1] - R[path_idx_2]) / ( L_tot / c)`\n\n    Parameters\n    ----------\n    path_response : ArrayLike\n        Timing response function for a collection of photon paths.\n    path_idx_1 : int\n        Index of the first photon path.\n    path_idx_2 : int\n        Index of the second photon path.\n    cumul_path_separations : ArrayLike\n        Cumulative path lengths for the photon paths.\n\n    Returns\n    -------\n    jnp.array\n        Michelson strain response for the two chosen photon paths.\n    \"\"\"\n    # get the cumulative path lengths for the two paths\n    total_length_1 = cumul_path_separations[:, path_idx_1, -1]\n    total_length_2 = cumul_path_separations[:, path_idx_2, -1]\n    total_length = 0.5 * (total_length_1 + total_length_2)\n    total_time = total_length / C_IN_AU_PER_S\n\n    # get the difference in the response functions\n    path_response_diff = path_response[path_idx_1] - path_response[path_idx_2]\n\n    # get the strain response\n    strain_response = path_response_diff / total_time[:, None, None, None]\n    return strain_response\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.get_pairwise_differential_strain_response","title":"<code>get_pairwise_differential_strain_response(path_response, cumul_path_separations)</code>","text":"<p>Calculate the strain response from the difference in the responses of two subsequent photon paths, of equal cumulative length, i.e.</p> <p><code>R_{diff} = (R[path_idx_1] - R[path_idx_2]) / ( L_tot / c)</code></p> <p>where <code>path_idx_1</code> and <code>path_idx_2</code> are even and odd successive indices.</p> <p>Parameters:</p> Name Type Description Default <code>path_response</code> <code>ArrayLike</code> <p>Timing response function for a collection of photon paths.</p> required <code>cumul_path_separations</code> <code>ArrayLike</code> <p>Cumulative path lengths for the photon paths.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Michelson strain response for all successive photon pairs.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def get_pairwise_differential_strain_response(\n    path_response: ArrayLike,\n    cumul_path_separations: ArrayLike,\n):\n    \"\"\"Calculate the strain response from the difference in the responses of two subsequent photon paths,\n    of equal cumulative length, i.e.\n\n    `R_{diff} = (R[path_idx_1] - R[path_idx_2]) / ( L_tot / c)`\n\n    where `path_idx_1` and `path_idx_2` are even and odd successive indices.\n\n    Parameters\n    ----------\n    path_response : ArrayLike\n        Timing response function for a collection of photon paths.\n    cumul_path_separations : ArrayLike\n        Cumulative path lengths for the photon paths.\n\n    Returns\n    -------\n    jnp.array\n        Michelson strain response for all successive photon pairs.\n    \"\"\"\n    total_length_cw = cumul_path_separations[:, ::2, -1]\n    total_length_ccw = cumul_path_separations[:, 1::2, -1]\n    total_length = 0.5 * (total_length_cw + total_length_ccw)\n    total_time = total_length / C_IN_AU_PER_S\n\n    path_response_diff = path_response[::2] - path_response[1::2]\n\n    strain_response = path_response_diff / total_time.T[..., None, None, None]\n\n    return strain_response\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.get_path_response","title":"<code>get_path_response(paths, freqs, arm_lengths, response)</code>","text":"<p>Calculate the timing response function for a collection of photon paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>ArrayLike</code> <p>Spacecraft indices for photon paths in shape (N_paths, N_depth).</p> required <code>freqs</code> <code>ArrayLike</code> <p>Frequencies of the gravitational wave in shape (N_freq,).</p> required <code>arm_lengths</code> <code>ArrayLike</code> <p>Arm lengths of the spacecraft in shape (N_pair, N_times).</p> required <code>response</code> <code>ArrayLike</code> <p>Response function for the given source direction</p> required <p>Returns:</p> Type Description <code>array</code> <p>Response function for the given source direction</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def get_path_response(\n    paths: ArrayLike,\n    freqs: ArrayLike,\n    arm_lengths: ArrayLike,\n    response: ArrayLike,\n):\n    \"\"\"Calculate the timing response function for a collection of photon paths.\n\n    Parameters\n    ----------\n    paths : ArrayLike\n        Spacecraft indices for photon paths in shape (N_paths, N_depth).\n    freqs : ArrayLike\n        Frequencies of the gravitational wave in shape (N_freq,).\n    arm_lengths : ArrayLike\n        Arm lengths of the spacecraft in shape (N_pair, N_times).\n    response : ArrayLike\n        Response function for the given source direction\n\n    Returns\n    -------\n    jnp.array\n        Response function for the given source direction\n    \"\"\"\n    indices = path_from_indices(paths)\n    N_pair = response.shape[0]\n    # N_pair = N * (N - 1), thus\n    N = round(jnp.sqrt(N_pair + 1 / 4) + 1 / 2)\n\n    flat_indices = jnp.apply_along_axis(\n        lambda indices: flat_index(*indices, N),\n        axis=-1,\n        arr=indices,\n    )\n    # print(flat_indices)\n\n    cumul_path_separations = get_cumulative_path_separations(flat_indices, arm_lengths)\n    # remove the last element of each path, as it does not appear in emitter phases\n    reduced_cumul_path_separations = cumul_path_separations[..., :-1]\n\n    cumul_path_phases = -2 * jnp.pi * jnp.outer(freqs, reduced_cumul_path_separations)\n    cumul_path_phases = (\n        cumul_path_phases.reshape(freqs.shape + reduced_cumul_path_separations.shape)\n        / C_IN_AU_PER_S\n    )\n    cumul_path_exp = jnp.exp(1j * cumul_path_phases)\n\n    path_responses = jnp.einsum(\n        \"ijkl,kljmin-&gt;kjmin\", cumul_path_exp, response[flat_indices]\n    )\n\n    return path_responses, cumul_path_separations\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.response_function","title":"<code>response_function(k_hat, freq, receiver_positions, full_transfer, antennae)</code>","text":"<p>Calculate the timing response function for a given source direction.</p> <p>Parameters:</p> Name Type Description Default <code>k_hat</code> <code>ArrayLike</code> <p>Unit vector pointing in the direction of propagation of the incoming signal.</p> required <code>freq</code> <code>ArrayLike</code> <p>Frequencies of the gravitational wave.</p> required <code>receiver_positions</code> <code>ArrayLike</code> <p>Positions of the receivers.</p> required <code>full_transfer</code> <code>ArrayLike</code> <p>Transfer function for the given source direction. Shape: (N_sky, N_freq, N_pair, N_times)</p> required <code>antennae</code> <code>ArrayLike</code> <p>Plus and cross antenna pattern functions. Shape: (N_sky, N_pair, N_times, N_pol)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Response function for the given source direction.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def response_function(\n    k_hat: ArrayLike,\n    freq: ArrayLike,\n    receiver_positions: ArrayLike,\n    full_transfer: ArrayLike,\n    antennae: ArrayLike,\n) -&gt; Array:\n    \"\"\"Calculate the timing response function for a given source direction.\n\n    Parameters\n    ----------\n    k_hat : ArrayLike\n        Unit vector pointing in the direction of propagation of the incoming\n        signal.\n    freq : ArrayLike\n        Frequencies of the gravitational wave.\n    receiver_positions : ArrayLike\n        Positions of the receivers.\n    full_transfer : ArrayLike\n        Transfer function for the given source direction.\n        Shape: (N_sky, N_freq, N_pair, N_times)\n    antennae : ArrayLike\n        Plus and cross antenna pattern functions.\n        Shape: (N_sky, N_pair, N_times, N_pol)\n\n    Returns\n    -------\n    jnp.array\n        Response function for the given source direction.\n    \"\"\"\n    if not (isinstance(freq, (jnp.ndarray, Array))) or jnp.isscalar(freq):\n        raise TypeError(f\"freq must be an array, got {type(freq)}\")\n\n    dot_product = jnp.dot(receiver_positions, k_hat) / C_IN_AU_PER_S\n    delta_phi = (\n        2\n        * jnp.pi\n        * jnp.outer(freq, dot_product).reshape(freq.shape + dot_product.shape)\n    )\n    delta_phi = jnp.moveaxis(delta_phi, -1, 0)\n    position_phase_shift = jnp.exp(-1j * delta_phi)\n\n    # include the position phase shift to the transfer function\n    full_transfer = full_transfer * position_phase_shift\n\n    # response function assuming no time delay\n    response_no_delay = 0.5 * jnp.einsum(\"ij...,i...k-&gt;...ijk\", full_transfer, antennae)\n    return response_no_delay\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.response_pipe","title":"<code>response_pipe(orbits, freqs, sky_basis)</code>","text":"<p>Calculate the response function for a given source direction.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def response_pipe(\n    orbits,\n    freqs,\n    sky_basis,\n):\n    \"\"\"Calculate the response function for a given source direction.\"\"\"\n    k_hat, u_hat, v_hat = sky_basis\n    separations = get_separations(orbits)\n\n    receiver_orbits = get_receiver_positions(orbits)\n    receiver_positions = flatten_pairs(receiver_orbits)\n\n    arms = flatten_pairs(separations)\n    arm_lengths = get_arm_lengths(arms)\n    arm_directions = arms / arm_lengths[..., None]\n\n    full_transfer = jitted_vmapped_transfer_function(k_hat, freqs, arms)\n    antennae = sky_vmapped_antenna_pattern(u_hat, v_hat, arm_directions)\n\n    response = response_function(\n        k_hat.T,\n        freqs,\n        receiver_positions,\n        full_transfer,\n        antennae,\n    )\n\n    return response, antennae\n</code></pre>"},{"location":"response/#src.jax_gw.detector.response.transfer_function","title":"<code>transfer_function(k_hat, freq, arms)</code>","text":"<p>Calculate the transfer function for a given source direction.</p> <p>Parameters:</p> Name Type Description Default <code>k_hat</code> <code>ArrayLike</code> <p>Unit vector pointing in the direction of propagation of the incoming signal.</p> required <code>freq</code> <code>ArrayLike</code> <p>Frequencies of the gravitational wave.</p> required <code>arms</code> <code>ArrayLike</code> <p>Arm configuration of the spacecraft.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Transfer function for the given source direction.</p> Source code in <code>src/jax_gw/detector/response.py</code> <pre><code>def transfer_function(\n    k_hat: ArrayLike,\n    freq: ArrayLike,\n    arms: ArrayLike,\n) -&gt; Array:\n    \"\"\"Calculate the transfer function for a given source direction.\n\n    Parameters\n    ----------\n    k_hat : ArrayLike\n        Unit vector pointing in the direction of propagation of the incoming\n        signal.\n    freq : ArrayLike\n        Frequencies of the gravitational wave.\n    arms : ArrayLike\n        Arm configuration of the spacecraft.\n\n    Returns\n    -------\n    jnp.array\n        Transfer function for the given source direction.\n    \"\"\"\n    if not (isinstance(freq, (jnp.ndarray, Array))) or jnp.isscalar(freq):\n        raise TypeError(f\"freq must be an array, got {type(freq)}\")\n\n    arm_length = get_arm_lengths(arms)\n\n    delta_t = arm_length - jnp.dot(arms, k_hat)\n    delta_t = delta_t / C_IN_AU_PER_S\n    L_over_c = arm_length / C_IN_AU_PER_S\n    # jnp outer flattens the array, so we need to reshape it\n    delta_phi = jnp.pi * jnp.outer(freq, delta_t).reshape(freq.shape + delta_t.shape)\n\n    return L_over_c * jnp.sinc(delta_phi / jnp.pi) * jnp.exp(-1j * delta_phi)\n</code></pre>"},{"location":"sky/","title":"Documentation for <code>detector.pixel</code>","text":"<p>Pixelization scheme module for jax-gw.</p> <p>This module contains functions for calculating the sky geometry.</p>"},{"location":"sky/#src.jax_gw.detector.pixel.flat_to_matrix_sky_indices","title":"<code>flat_to_matrix_sky_indices(N_theta, N_phi)</code>","text":"<p>Calculate the (N_theta*N_phi, 2) matrix of flat indices for a given sky resolution.</p> <p>Parameters:</p> Name Type Description Default <code>N_theta</code> <code>int</code> <p>Number of ecliptic thetas.</p> required <code>N_phi</code> <code>int</code> <p>Number of ecliptic phis.</p> required <p>Returns:</p> Type Description <code>ArrayLike</code> <p>Matrix of flat indices.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def flat_to_matrix_sky_indices(N_theta: int, N_phi: int):\n    \"\"\"Calculate the (N_theta*N_phi, 2) matrix of flat indices for a given sky resolution.\n\n    Parameters\n    ----------\n    N_theta : int\n        Number of ecliptic thetas.\n    N_phi : int\n        Number of ecliptic phis.\n\n    Returns\n    -------\n    ArrayLike\n        Matrix of flat indices.\n    \"\"\"\n    # without for loop or list comprehension\n    a = jnp.arange(N_theta * N_phi)\n\n    i = jnp.floor_divide(a, N_phi)\n    j = jnp.mod(a, N_phi)\n\n    return jnp.stack([i, j], axis=1)\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.flatten_sky","title":"<code>flatten_sky(i_theta, j_phi, N_phi)</code>","text":"<p>Flatten the sky coordinates into a single index.</p> <p>Parameters:</p> Name Type Description Default <code>i_theta</code> <code>int</code> <p>Index of the ecliptic theta.</p> required <code>j_phi</code> <code>int</code> <p>Index of the ecliptic phi.</p> required <code>N_phi</code> <code>int</code> <p>Number of ecliptic phis.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Flattened index.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def flatten_sky(i_theta: int, j_phi: int, N_phi: int) -&gt; int:\n    \"\"\"Flatten the sky coordinates into a single index.\n\n    Parameters\n    ----------\n    i_theta : int\n        Index of the ecliptic theta.\n    j_phi : int\n        Index of the ecliptic phi.\n    N_phi : int\n        Number of ecliptic phis.\n\n    Returns\n    -------\n    int\n        Flattened index.\n    \"\"\"\n    return i_theta * N_phi + j_phi\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.get_directional_basis","title":"<code>get_directional_basis(ecl_theta, ecl_phi)</code>","text":"<p>Calculate the directional basis for a given source direction.</p> <p>Parameters:</p> Name Type Description Default <code>ecl_theta</code> <code>ArrayLike</code> <p>Ecliptic latitude of the source.</p> required <code>ecl_phi</code> <code>ArrayLike</code> <p>Ecliptic phi of the source.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Directional basis k_hat, u_hat, v_hat, where k_hat is the direction of the incoming signal, u_hat is same as theta_hat, and v_hat is same as phi_hat.</p> <p>Note that k, u, v are not a right-handed coordinate system, but -k, u, v is.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def get_directional_basis(ecl_theta: ArrayLike, ecl_phi: ArrayLike) -&gt; Array:\n    \"\"\"Calculate the directional basis for a given source direction.\n\n    Parameters\n    ----------\n    ecl_theta : ArrayLike\n        Ecliptic latitude of the source.\n    ecl_phi : ArrayLike\n        Ecliptic phi of the source.\n\n    Returns\n    -------\n    jnp.array\n        Directional basis k_hat, u_hat, v_hat, where k_hat is the direction of the\n        incoming signal, u_hat is same as theta_hat, and v_hat is same as phi_hat.\n\n        Note that k, u, v are not a right-handed coordinate system, but -k, u, v is.\n    \"\"\"\n    cos_theta = jnp.cos(ecl_theta)\n    sin_theta = jnp.sin(ecl_theta)\n    cos_phi = jnp.cos(ecl_phi)\n    sin_phi = jnp.sin(ecl_phi)\n    zero_element = jnp.zeros_like(cos_theta)\n\n    k_hat = -jnp.stack(\n        [sin_theta * cos_phi, sin_theta * sin_phi, cos_theta],\n        axis=-1,\n    )\n    # u_hat is theta_hat, v_hat is phi_hat\n    u_hat = jnp.stack([cos_theta * cos_phi, cos_theta * sin_phi, -sin_theta], axis=-1)\n    v_hat = jnp.stack([-sin_phi, cos_phi, zero_element], axis=-1)\n\n    return jnp.stack([k_hat, u_hat, v_hat], axis=0)\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.get_solid_angle_theta_phi","title":"<code>get_solid_angle_theta_phi(theta, phi, N_theta, N_phi)</code>","text":"<p>Get the sky area associated with a given theta and phi in a pixelated sphere. Assumes linear spacing in theta and phi.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Ecliptic theta.</p> required <code>phi</code> <code>float</code> <p>Ecliptic phi.</p> required <code>N_theta</code> <code>int</code> <p>Number of theta bins.</p> required <code>N_phi</code> <code>int</code> <p>Number of phi bins.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Sky area associated with theta and phi.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def get_solid_angle_theta_phi(theta, phi, N_theta, N_phi):\n    \"\"\"Get the sky area associated with a given theta and phi in a\n    pixelated sphere. Assumes linear spacing in theta and phi.\n\n    Parameters\n    ----------\n    theta : float\n        Ecliptic theta.\n    phi : float\n        Ecliptic phi.\n    N_theta : int\n        Number of theta bins.\n    N_phi : int\n        Number of phi bins.\n\n    Returns\n    -------\n    float\n        Sky area associated with theta and phi.\n    \"\"\"\n    delta_phi = 2 * jnp.pi / N_phi\n    delta_theta = jnp.pi / (N_theta - 1)\n    min_phi = phi - delta_phi / 2\n    max_phi = phi + delta_phi / 2\n    min_theta = jnp.maximum(theta - delta_theta / 2, 0)\n    max_theta = jnp.minimum(theta + delta_theta / 2, jnp.pi)\n    solid_angle = (max_phi - min_phi) * (jnp.cos(min_theta) - jnp.cos(max_theta))\n    return solid_angle\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.pixel_to_lm","title":"<code>pixel_to_lm(data_omega, axis, N_theta, N_phi, ecl_thetas, ecl_phis, sph_harm_values)</code>","text":"<p>Convert a pixelated map to a spherical harmonic map.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def pixel_to_lm(\n    data_omega, axis, N_theta, N_phi, ecl_thetas, ecl_phis, sph_harm_values\n):\n    \"\"\"Convert a pixelated map to a spherical harmonic map.\"\"\"\n    # sky axis last, preceded by two axes for l and m\n    data_omega = jnp.moveaxis(data_omega, axis, -1)[..., None, None, :]\n    data_lm = sph_harm_values * data_omega\n    data_lm = data_lm * get_solid_angle_theta_phi(ecl_thetas, ecl_phis, N_theta, N_phi)\n    data_lm = jnp.sum(data_lm, axis=-1)\n    return data_lm\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.unflatten_sky","title":"<code>unflatten_sky(index, N_phi)</code>","text":"<p>Unflatten the sky coordinates from a single index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Flattened index.</p> required <code>N_phi</code> <code>int</code> <p>Number of ecliptic phis.</p> required <p>Returns:</p> Type Description <code>NamedTuple</code> <p>Unflattened sky coordinates.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def unflatten_sky(index: int, N_phi: int):\n    \"\"\"Unflatten the sky coordinates from a single index.\n\n    Parameters\n    ----------\n    index : int\n        Flattened index.\n    N_phi : int\n        Number of ecliptic phis.\n\n    Returns\n    -------\n    NamedTuple\n        Unflattened sky coordinates.\n    \"\"\"\n    i_theta = index // N_phi\n    j_phi = index % N_phi\n\n    return i_theta, j_phi\n</code></pre>"},{"location":"sky/#src.jax_gw.detector.pixel.unflatten_sky_axis","title":"<code>unflatten_sky_axis(matrix, axis, N_theta, N_phi)</code>","text":"<p>Unflatten the axis of a matrix that corresponds to the sky coordinates.</p> <p>Shape is converted from (...N, N_theta*N_phi, M...) to (...N, N_theta, N_phi, M...).</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ArrayLike</code> <p>Matrix to unflatten.</p> required <code>axis</code> <code>int</code> <p>Axis to unflatten.</p> required <code>N_theta</code> <code>int</code> <p>Number of ecliptic thetas.</p> required <code>N_phi</code> <code>int</code> <p>Number of ecliptic phis.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Unflattened matrix.</p> Source code in <code>src/jax_gw/detector/pixel.py</code> <pre><code>def unflatten_sky_axis(matrix, axis: int, N_theta: int, N_phi: int) -&gt; Array:\n    \"\"\"Unflatten the axis of a matrix that corresponds to the sky coordinates.\n\n    Shape is converted from (...N, N_theta*N_phi, M...) to (...N, N_theta, N_phi, M...).\n\n    Parameters\n    ----------\n    matrix : ArrayLike\n        Matrix to unflatten.\n    axis : int\n        Axis to unflatten.\n    N_theta : int\n        Number of ecliptic thetas.\n    N_phi : int\n        Number of ecliptic phis.\n\n    Returns\n    -------\n    jnp.array\n        Unflattened matrix.\n    \"\"\"\n    flat_to_matrix = jnp.arange(N_theta * N_phi).reshape(N_theta, N_phi)\n\n    return jnp.take(matrix, flat_to_matrix, axis=axis)\n</code></pre>"}]}